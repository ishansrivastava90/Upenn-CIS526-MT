Um RTOS facilita a concepção de um sistema em tempo real, mas não garante que o resultado final seja um sistema de tempo real, para tal é necessário que o programa nele implementado tenha sido corretamente desenvolvido. Um RTOS não tem que ter necessariamente um elevado débito nas saídas, ou um elevado número de saídas, no entanto, tem que garantir que certas tarefas sejam executadas em um determinado intervalo de tempo. Um RTOS é mais eficaz e é mais valorizado pela forma previsível e rápida na resposta a um evento, do que pela quantidade de dados que processa. Os fatores chave em um STR são, então, fornecer latências de interrupções e de alternância de tarefas mínimas. O desenho baseado no evento, ou escalonamento prioritário, alterna as tarefas somente, quando uma tarefa de maior prioridade necessita de ser executada, denominando-se preemptividade. O desenho baseado na partilha de tempo alterna as tarefas segundo os tiques do relógio do processador. O desenho que se baseia na partilha de tempo, alterna entre tarefas mais frequentemente daquilo que é realmente necessário, no entanto dá a estas a ilusão de terem o monopólio do processador. Os processadores mais antigos, necessitavam de muitos ciclos de relógio para alternarem entre tarefas, sendo que nesse intervalo de tempo não executavam nada. Então os RTOS dessa época tentavam minimizar o desperdício de tempo do processador através da diminuição de alternância entre tarefas. Os processadores mais recentes demoram muito menos tempo para mudarem de uma tarefa para outra. Quase todos os RTOS de hoje em dia implementam uma junção destes dois tipos de desenhos. Como os demais sistemas operacionais, os RTOS têm uma fila onde se inserem todas as tarefas que estão prontas para serem executadas. Essa lista é conhecida como fila de prontos. Os algoritmos de escalonamento desses sistemas visam, principalmente, satisfazer os requisitos temporais das tarefas. Como cada sistema implementa, na maioria das vezes, algoritmos de escalonamento diferentes, alguns são aptos para determinadas tarefas enquanto outros são melhores para outras aplicações. O RTLinux, utilizado nas indústrias para controle e automação, permite que um programador escreva seu próprio algoritmo de escalonamento. O RMS atribui prioridades aos processos dependendo do número de vezes que eles serão executados por segundo. Quanto maior a freqüência de execução, maior a prioridade. O escalonamento por taxas monotônicas é preemptivo. O STR Não-Crítico é aquele que também tem o tempo como parâmetro fundamental, mas uma falha é aceitável. O sistema que funciona em um leitor de DVD não é crítico, pois o não cumprimento de uma tarefa em resposta e um evento em um determinado intervalo de tempo não provoca danos irreversíveis. Ao contrário dos sistemas críticos, esses sistemas normalmente trabalham com um grande volume de dados. Os RTS rígidos são inflexíveis, pois o estatístico, para obter o grau de validade e utilidade dos dados lidos depois do prazo da tarefa terminar. Surgem no entanto alguns problemas relacionados com os semáforos binários, entre os quais a prioridade invertida e o entrave. Na prioridade invertida uma tarefa de alta prioridade é obrigada a esperar porque uma tarefa de baixa prioridade bloqueou um semáforo. Se uma tarefa de baixa prioridade bloquear um semáforo, impede que uma tarefa que verifica o estado desse semáforo, seja executada, mesmo sendo de prioridade superior. Um solução pode ser, atribuir temporariamente uma prioridade elevada, à tarefa que está a bloquear o semáforo, por forma a que esta desimpeça o recurso o mais rapidamente possível. Num entrave, duas ou mais tarefas bloqueiam uma série de semáforos binários e esperam infindavelmente pelo desbloqueio de outros semáforos, criando assim ciclos infinitos. Se uma tarefa A bloquear o semáforo f1 e depois esperar pelo desbloqueio do semáforo f2, e uma tarefa B estiver bloqueada no semáforo f1 para desbloquear o semáforo f2, cria-se um entrave TANENBAUM, A. S. Sistemas Operacionais Modernos. 2ª ed. São Paulo, Pearson Prentice Hall, 2003.
