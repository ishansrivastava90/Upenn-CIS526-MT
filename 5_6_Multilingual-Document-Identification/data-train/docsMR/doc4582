مهم‌ترین علت استفاده از ترجمه کد مبدا، ایجاد برنامه اجرایی می‌باشد. برعکس برنامه‌ای که زبان سطح پایین را به بالاتر تبدیل می‌کند را decompiler گوییم. ترجمه کامل کد منبع برنامه‌ای از یک زبان سطح بالا به کد شیء، پیش از اجرای برنامه را همگردانی یا کامپایل می‌گویند. در اولین نگاه، تنوع کامپایلرها ممکن است به چشم نیاید. تعداد بسیار زیادی زبان‌های منبع وجود دارند که دامنه آنها از زبان‌های شناخته شده مانند فرترن و پاسکال تا زبان‌های خاص منظوره گسترده است. زبان‌های مقصد نیز گستردگی متناظر با این زبان‌ها دارند. یک زبان مقصد ممکن است زبان برنامه‌سازی دیگر یا زبان ماشین یا ... باشد. کامپایلرها به انواع تک‌گذره، چند گذره، باردهی و اجرا، بهینه‌ساز، غلط یاب و ... بسته با عمل انجام شده تقسیم می‌شوند. علیرغم این تنوع اعمال اساسی که هر کامپایلر بایستی انجام دهد، مشابه هم می‌باشند. دانسته‌های ما در مورد سازمان‌بندی و نوشتن کامپایلر نسبت به زمانی که اولین کامپایلرها در اوایل دهه 1950 ایجاد شدند، بسیار افزایش یافته است. تخمین تاریخ دقیق ساخت اولین کامپایلر عمل آسانی نیست، زیرا گروه‌های متفاوتی نسبت به ساخت کامپایلرها در آن زمان اقدام نموده‌اند. اولین کارهایی که در ساخت کامپایلرها انجام شد، تبدیل فرمول‌های ریاضی به زبان ماشین بود. در اواسط دهه ۱۹۵۰ کامپایلرها به عنوان برنامه‌هایی دشوار شناخته شده بودند. اولین کامپایلر فرترن، به عنوان مثال ۱۸ سال زمان برای طراحی صرف نمود. از آن زمان روش‌های سیستماتیک برای استفاده از بسیاری اعمال مهم حین عمل کمپایل ابداع شده‌است. همچنین زبان‌های پیاده‌سازی خوب، محیط‌های برنامه نویسی و ابزارهای نرم‌افزاری مناسب ایجاد شده‌اند. با کمک این پیشرفت‌ها یک کامپایلر را می‌توان حتی به عنوان پروژه درسی در یک ترم تحصیلی دانشجویی طراحی نمود. در اواخر دهه ۱۹۵۰ میلادی ماشین‌های دارای زبانهای برنامه نویسی رواج یافتند و کامپایلرهای آزمایشی ایجاد شدند. زبان فرترن به سرپرستی جان باکوس در شرکت آی‌بی‌ام به عنوان اولین کامپایلر کامل در سال ۱۹۵۷ تولید شد. کوبول اولین زبان کامپایلی با معماری چندگانه در سال ۱۹۶۰ تولید شد. در طی دهه ۶۰ کامپایلرهای زیادی تولید شد اما بر روی کیفیت کامپایلرها کمتر فکر می‌شد. هم‌زمان با تکامل زبان‌های برنامه سازی و افزایش قدرت کامپیوترها، کامپایلرها هرچه بیشتر پیچیده می‌شدند. یک کامپایلر خود برنامه‌ای است که توسط زبان پیاده ساز تولید شده‌است. اولین کامپایلر خود محور که می‌توانست کد خود را کامپایل کند برای زبان پاسکال و سی جهت نوشتن کامپایلرها استفاده شد. ساخت کامپایلرهای خود محور دارای مشکل راه اندازی است، چونکه هر کامپایلری باید توسط کامپایلر نوشته شده‌ای به زبان دیگر کامپایل شود یا برای این مشکل دست به دامن مفسری بشود. در دهه‌های ۱۹۶۰و۱۹۷۰ زبانهای برنامه‌سازی جدید به وجود آمدند و طراحان زبان معتقد بودند که طراحی سریع کامپایلر برای زبان جدید , مهم‌تر از وجود کامپایلری با کد کارآمد است.بدین ترتیب , در ساخت کامپایلر به پردازشگر جلویی تاکید شده‌است. در همین زمان , مطالعه زبانهای رسمی , تکنیکهای قدرتمندی را برای ساخت پردازشگر جلوی , بخصوص تولید تجزیه کننده به وجود آورد از ۱۹۷۵ تاکنون , تعداد زبانهای جدید و انواع ماشین مختلف کاهش یافت در نتیجه نیاز به کامپایلرهای سریع و ساده یا سریع و ناقص برای زبانها یا ماشینهای جدید , کاهش یافت. بزرگ‌ترین آشفتگی در طراحی زبان و ماشین خاتمه یافت و افراد خواستار کامپایلرهای قابل اعتماد , کارآمد و با واسط کاربر مناسب شدند. بدین ترتیب , توجه کیفی به کد بیشتر شد زیرا با تغیر اندکی که در ساختار ماشینها ایجاد می‌شود , طول عمر کدها افزایش می‌یابد.در همین دوره , مدلهایی در برنامه نویسی به وجود آمدند که برنامه نویسی تابعی , منطقی و توزیعی نمونه‌های از این مدلها هستند, خواسته‌های زمان اجرای این زبانها نسبت به زبانهای دستور, افزایش یافت. «البته در ابتدای امر که در مورد زبانهای تفسیری و کامپایلری گفته بودند باید خاطر نشان کرد که زبانهای تفسیری خط به خط خوانده شده و اجرا می‌گردد در حالیکه در کامپایلری ابتدا تمام برنامه ترجمه شده و سپس اجرا می‌گردد پس در زمان اجرا سرعت اجرا شدن زبانهای کامپایلری بیشتر است. اما کشف و تصحیح خطا در تفسیری بهتر و راحت تر است.»