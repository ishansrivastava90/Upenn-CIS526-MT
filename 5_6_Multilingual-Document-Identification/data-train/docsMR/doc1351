A megszakítás-elvű kivételkezeléses rendszerben a hibákat könnyebb elfogni, valamint a nyelvek általában egy beépített eljárással kezelik a hibákat, ha mi nem tettük volna meg. Ezért a kivételek használata és az ezekkel való munka mindenképpen egy magasabb szintű, felügyelt hibakezelést tesz lehetővé. Később, az PC-s világban már a Pascal, a C stb. Később ez a tendencia átterjedt a script-szerű nyelvekre is. Ez furcsa, mivel pont az interpretált kódoknál könnyebb a magas szintű hibakezelés megvalósítása. Így manapság szinte mindegyik komolyabb programozási nyelv alkalmazza a kivételeket ilyen-olyan formában. Az objektumorientált programnyelvek általában objektumokba burkolják a kivételek, így lehetőséget biztosítanak arra, hogy azokat leszármaztassuk és saját elemekkel bővítsük őket, olyan plusz információk hordozására bírva ezeket, amelyekkel a szülő elemek nem rendelkeztek. A kivételkezeléses módszernél két blokkot definiálunk. Az elsőben magát az egésszé alakító utasítást helyezzük el, a másodikban pedig a hiba előfordulásakor lefutó kódsort. Ebbe a szakaszba helyezzük el azokat az utasításokat, amelyekben hibát "várunk". Tulajdonképpen kipróbáljuk, hogy történik-e hiba. Ha nem, akkor a blokkban szereplő utasítások lefutnak, majd a következő utasításhalmazhoz kerülünk. Ezen blokkokba kerül a végrehajtás, ha valamilyen hiba fordult elő. Általában a programnyelvek támogatják a kivételtípusok szerinti szelekciót, vagy a kivételekből információk kinyerését. E kódszakaszba tehetünk minden kezelőt, vagy reagáló elemet, amit a hiba kiküszöbölése, vagy észlelése miatt be akarunk vetni. E kódblokk tartalmaz minden olyan kritikus utasítást, aminek mindenképpen le kell futni – még kivétel bekövetkezte esetén is ! Vagyis ide teendő minden erőforráskezelő rutin – általában az összes felszabadító, elengedő szekvenciát ide érdemes halmozni, ami kapcsolatban lehet a védendő kódszakasszal. A kompilált kódok esetében egy speciális kezelőt regisztrálunk az operációs rendszer számára. E kód a veremben, vagy egyéb területen elhelyezett jelzők alapján fogja tudni kideríteni, hogy hol kell folytatódnia a kódnak kivétel történte esetén. Interpretált nyelveknél ezeket a funkciókat az értelmező és futtató modul végzi. A fenti elemeket a megfelelő erőforráskezelés számára kiegészítették egy újjal – hiszen a program futása a kivételekre "várakozás" miatt nem várt irányba is folytatódhat, aminek okán az előzőleg lefoglalt erőforrások nem kerülnek felszabadításra – memóriafolyást, memóriahiányt okozva. Ezért egy olyan blokkot is definiálhatunk, amelynek célja a mindenkoron – akár kivétel bekövetkezte esetén is – történő lefutás. Több nyelvnél a "finally" taghoz tartozó kódblokk általában előbb fut le, mint az "except" szakasz.