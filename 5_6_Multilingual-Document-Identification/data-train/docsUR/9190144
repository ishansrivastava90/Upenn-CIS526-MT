An atomic commit is an operation in which a set of distinct changes is applied as a single operation. If the changes are applied then the atomic commit is said to have succeeded. If there is a failure before the atomic commit can be completed then all of the changes completed in the atomic commit are reversed. This insures that the system is always left in a consistent state.  The other key property of isolation comes from their nature as database system and revision control system systems. This example is complicated by a transaction to check the balance of account Y during a transaction for transferring 100 dollars from account X to Y. To start, first 100 dollars is removed from account X. Second, 100 dollars is added to account Y. If the entire operation is not completed as one atomic commit several problems could occur. If the system fails in the middle of the operation, after removing the money from X and before adding into Y, then 100 dollars has just disappeared. Another issue is if the balance of Y is checked before the 100 dollars is added. The wrong balance for Y will be reported. With atomic commits neither of these cases can happen, in the first case of the system failure, the atomic commit would be rolled back and the money returned to X. In the second case, the request of the balance of Y cannot occur until the atomic commit is fully completed. Atomic commits in database systems fulfil two of the key properties of atomicity and  consistency.  Consistency is only achieved if each change in the atomic commit is consistent. As shown in the example atomic commits are critical to multistep operations in databases. Due to modern hardware design the physical disk on which the database resides true atomic commits cannot exist. The smallest area that can be written to on disk is known as a sector. A single database entry may span several different sectors. Only one sector can be written at a time. This writing limit is why true atomic commits are not possible. After the database entries in memory have been modified they are queued up to be written to disk. This means the same problems identified in the example have reoccurred. Any algorithmic solution to this problem will still encounter the Two Generalsâ€™ Problem. The two-phase commit protocol and three-phase commit protocol attempt to solve this some of the problems associated with atomic commits. Like database systems commits may fail do to a problem in applying the changes on disk. Unlike a database system which overwrites any existing data with the data from the changeset revision control systems merge the modification in the changeset into the existing data. If the system cannot complete the merge then the commit will be rejected. If a merge cannot be resolved by the revision control software it is up to the user to merge the changes. For revision control systems that support atomic commits this failure in merging would result in a failed commit. Atomic commits are crucial for maintaining a consistent state in the repository. Without atomic commits some changes a developer has made may be applied but other changes may not. If these changes have any kind of coupling this will result in errors. Atomic commits prevent this by not applying partial changes which would create these errors. Note that if the changes already contain errors atomic commits do not help fix those it will only prevent new errors. Atomic commits also allow bug fixes to be easily reviewed if only a singe bug fixes committed at a time. Instead of having to check multiple potentially unrelated files the reviewer must only check files and changes that directly impact the bug being fixed.This also means that bug fixes can be easily packaged for testing as only the changes that fix the bug are in the commit.