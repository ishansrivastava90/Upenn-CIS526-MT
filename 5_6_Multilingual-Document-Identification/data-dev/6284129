przetwarzaniu współbieżnym w celu uniknięcia równoczesnego używania zasobów, takich jak zmienne globalne, przez części kodu wywołanych w sekcjach krytycznych.  Sekcja krytyczna sama w sobie nie jest ani mechanizmem, ani algorytmem wzajemnego wykluczania. Program, proces lub wątek może posiadać sekcje krytyczne bez mechanizmów czy algorytmów implementujących wzajemne wykluczanie. Przykładami są flagi drobnoziarniste, liczniki czy kolejki, używane do komunikacji pomiędzy wykonywanymi współbieżnie częsciami kodu, takich jak aplikacje i ich obsługi wykluczeń. Problem jest wrażliwy ponieważ wątki mogą być zatrzymywane i uruchamiane w różnych momentach. Nazwą mutex można określać obiekty negocjujące pomiędzy wątkami, nazywane również blokadami. Na systemach jedno-procesorowych najczęstszym sposobem wzajemnego wykluczania w jądrach systemów operacyjnych jest wyłączenie przerwań dla jak najmniejszej ilości instrukcji kodu, chroniąc przed uszkodzeniem struktury dzielonych danych sekcji krytycznej. Zapobiega to uruchamianiu kodu w sekcji krytycznej, oraz chroni przed zmianami procesów opartych na technologii przerwań. W komputerach, które dzielą pamięć miedzy własnymi procesorami, niepodzielna instrukcja test-and-set flagi jest używana w pętlach w celu przeczekania do momentu aż procesor wyczyści flagę. Instrukcja ta przeprowadza dwie operacje bez wypuszczania pamięci z wyłączności. Kiedy kod opuszcza sekcje krytyczną, czyści flagę. Nazywa się to „Spinlock” lub „Busy wait”. Podobną operacją atomową jest “compare-and-swap” używana do synchronizacji nieblokującej dla list lączonych i innych struktur danych. Najklasyczniejszymi metodami zmniejszenia opóźnienia i „Busy wait” jest używanie kolejek i przełączanie kontekstu. Wiele sposobów wzajemnego wykluczania maja efekty uboczne. Na przykład, klasyczne semafory mogą prowadzić do zakleszczeń, w których jeden proces dostaje semafor, kiedy inny proces dostaje drugi semafor, może dojść do zakleszczenia gdzie oba procesy czekają na wzajemnie przez siebie zajęte semafory. Inny efekt uboczny polega na zagłodzeniu, w którym jeden proces nigdy nie otrzyma wystarczającej ilości zasobów do wykonania polecenia, inwersja priorytetów w której wątek o wyższym priorytecie czeka na wątek z niższym priorytetem, gdzie duże opóźnienie może powodować brak odpowiedzi na przerwanie. Badania skierowane na eliminowaniu powyższych efektów, polega na gwarantowaniu synchronizacji nieblokujących. Nie opisano do tej pory schematów bez skutków ubocznych.